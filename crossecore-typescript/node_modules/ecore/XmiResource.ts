/* CrossEcore is a cross-platform modeling framework that generates C#, TypeScript,
 * JavaScript, Swift code from Ecore models with embedded OCL (http://www.crossecore.org/).
 * The original Eclipse Modeling Framework is available at https://www.eclipse.org/modeling/emf/.
 *
 * contributor: Simon Schwichtenberg
 */



import {EPackage} from "ecore/EPackage";
import {EcorePackageImpl} from "ecore/EcorePackageImpl";
import {EcoreFactoryImpl} from "ecore/EcoreFactoryImpl";

import {EClass} from "ecore/EClass";
import {EObject} from "ecore/EObject";
import {EFactory} from "ecore/EFactory";

import {EReference} from "ecore/EReference";

import {ENamedElement} from "ecore/ENamedElement";
import {EReferenceImpl} from "ecore/EReferenceImpl";
import {EClassImpl} from "ecore/EClassImpl";
import {ENamedElementImpl} from "ecore/ENamedElementImpl";
import {EAttributeImpl} from "ecore/EAttributeImpl";


export class XmiResource{

    private factory:EFactory = EcoreFactoryImpl.eINSTANCE;
    private epackage:EPackage = EcorePackageImpl.eINSTANCE; //TODO make dynamic
    private domParser:DOMParser;


    private root:EObject;

    private resolveJobs:any = []; //TODO define type


    constructor(epackage:EPackage, efactory:EFactory, domParser:DOMParser){
        this.factory = efactory;
        this.epackage = epackage;

        this.domParser = domParser;
    }




    public load = (xml:string):EObject =>{

        let parser = this.domParser;
        let xmlDoc = parser.parseFromString(xml,"text/xml");

        this.rootnode(xmlDoc.childNodes[2] as Element);

        return this.root;
    }

    public rootnode = (node:Element) => {


        let classifierId = node.nodeName.split(':')[1];

        let eclassifier = this.epackage.getEClassifier(classifierId);

        if(eclassifier instanceof EClassImpl){

            let eclass = eclassifier as EClass;

            this.root = this.factory.create(eclass);

            this.addEStructuralFeatures(this.root, node)
        }


    }

    protected resolveEList = (specification:string)=>{



        let result = new Array<EObject>();
        let supertypes = specification.split(' ');

        if (supertypes != null)
        {

            for(let i=0;i<supertypes.length;i++){
                //for (string s in supertypes)

                let s = supertypes[i];

                let supertype = this.resolveEObject(s) as EClass;
                //TODO assure it is eclass
                result.push(supertype);
            }
        }
        return result;


    }

    protected resolveEObject(specification:string){
        if(specification===null){
            return null;
        }
        else if(specification.lastIndexOf("#//")===0){

            let name = specification.replace("#//", "");
            let segments = name.split("/");

            let queue = new Array<string>();


            for(let i=0;i<segments.length;i++){
                let segment = segments[i];

                queue.push(segment);
            }

            this.resolveRecurr(queue, this.root);


        }
    }

    private resolveRecurr = (path:Array<string>, current:EObject )=>{

        if(path.length===0){
            return current;

        }

        let segment = path.shift();

        //FIXME: eContents needs to return Array
        let econtents = new Array<EObject>();//current.eContents();

        for(let i=0; i<econtents.length;i++){

            let content = econtents[i] as EObject;

            if(content instanceof ENamedElementImpl){

                if((content as ENamedElement).name===segment){
                    return this.resolveRecurr(path, content)
                }
            }
        }




    }

    public addEStructuralFeatures = (eobject:EObject, node:Element)=>{


        for (let i = 0; i < node.attributes.length; i++) {



            let attribute = node.attributes[i];



            let name = attribute.name;

            let estructuralfeature = eobject.eClass().getEStructuralFeature(name);

            if (estructuralfeature instanceof EAttributeImpl){

                let etype = estructuralfeature.eType;
                let value = attribute.value;

                if(etype.ePackage.nsURI==="http://www.eclipse.org/emf/2002/Ecore"){

                    if (etype.name === "EBoolean")
                    {
                        eobject.eSet(estructuralfeature, value == "true" ? true : false);
                    }
                    else if (etype.name === "EInt")
                    {
                        eobject.eSet(estructuralfeature, parseInt(value));
                    }
                    else if (etype.name === "EString")
                    {
                        eobject.eSet(estructuralfeature, value);
                    }
                }
                else if (estructuralfeature.many)
                {

                }
            }
            else if (estructuralfeature instanceof EReferenceImpl)
            {
                //TODO
                //this.resolveJobs.push({eobject, estructuralfeature, attribute.value});

            }

        }



        for (let i = 0; i < node.childNodes.length; i++) {
            let child = node.childNodes[i];



            if(child.nodeType === child.ELEMENT_NODE){


                let element = child as Element;
                let containment_name = child.localName;

                let containment = eobject.eClass().getEStructuralFeature(containment_name);

                if(containment instanceof EReferenceImpl){

                    let containment_er = containment as EReferenceImpl;


                    if(containment_er.containment){

                        let classifierId2 = containment.eType.name;

                        for(let i=0; i< element.attributes.length;i++){
                            if(element.attributes[i].name==='xsi:type'){
                                classifierId2 = element.attributes[i].name.split(':')[1];
                            }
                        }

                        let eclassifier2 = this.epackage.getEClassifier(classifierId2);


                        if (eclassifier2 instanceof EClassImpl)
                        {



                            if (containment_er.eType.name === "EStringToStringMapEntry")
                            {

                                //TODO
                            }
                            else
                            {
                                var eclass2 = eclassifier2 as EClass;
                                var eobject2 = this.factory.create(eclass2);

                                if (containment_er.many)
                                {
                                    this.addEStructuralFeatures(eobject2, element);//TODO is Element cast safe here?

                                    var list = new Array<EObject>();
                                    list.push(eobject2);
                                    eobject.eSet(containment_er, list);
                                }
                                else
                                {
                                    this.addEStructuralFeatures(eobject2, element);//TODO is Element cast safe here?

                                    eobject.eSet(containment_er, eobject2);
                                }

                            }

                        }

                    }
                }
            }

        }
    }



}


